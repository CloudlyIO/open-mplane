/*!
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * \file      YangManagerTestHelper.cpp
 * \brief     Test helper for ORANRRH
 *
 *
 * \details   Auto-generated by gentool. Contains test interface definitions. Please add your own
 * code between the %%--> and <--%% comment lines (any code outside these comments will be discarded
 * next time the generate tool is run)
 *
 */


//=============================================================================================================
// INCLUDE
//=============================================================================================================
#include "RtiKeyword.h"
#include "YangManagerTestHelper.h"

// Add any specific includes here %%-->

#include <string>
#include <vector>
#include <algorithm>
#include "YangMgrServer.h"
#include "YangMgrService.h"
#include "YangParamSysrepo.h"
#include "YangTypes.h"
#include "IYangConfig.h"

// <--%%


using namespace Mplane ;

// Add any statics, types, prototypes etc here %%-->

// <--%%



//=============================================================================================================
// SINGLETON
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
std::shared_ptr<YangManagerTestHelper> YangManagerTestHelper::getInstance()
{
	static std::shared_ptr<YangManagerTestHelper> instance(std::make_shared<YangManagerTestHelper>()) ;
	return instance ;
}

//=============================================================================================================
// PUBLIC
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
YangManagerTestHelper::YangManagerTestHelper()
// Insert additional inheritance constructors here : %%-->

// <--%%
{
	// Insert your code here : %%-->

	// <--%%
}

//-------------------------------------------------------------------------------------------------------------
YangManagerTestHelper::~YangManagerTestHelper()
{
	// Insert your code here : %%-->

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void YangManagerTestHelper::getInstalledModuleList( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// *
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING Modules
	//

	// Insert your code here : %%-->
    std::shared_ptr<YangMgrService> yangService(YangMgrService::singleton()) ;
	std::shared_ptr<YangMgrServer> yangMgr(yangService->getYangMgrServer()) ;

	std::vector<std::string> installedModules = yangMgr->getSupportedModuleList();
	// This is a comma separated list.
	std::string modules = "\0";

	for (auto &elem : installedModules)
	{
		modules += elem;
		modules += "\n";
	}

	returnList->find("Modules")->set(modules) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void YangManagerTestHelper::getModuleFeatures( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * STRING module
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING Features
	//

	// Insert your code here : %%-->
	std::shared_ptr<IYangConfig> yangCfg = IYangConfig::getConfigSingleton();

	std::string module = callList->find("module")->toString();

	// Get list of enabled features from parser
	std::map<std::string, bool> featureList;
	std::string moduleFeatures = "";

	yangCfg->listModuleFeatures(module, featureList);

	// Enable/Disable each feature in from the list
	for (auto &feature : featureList)
	{
		moduleFeatures += feature.first;
		moduleFeatures += (feature.second == true ? " = Enabled\n" : " = Disabled\n");
	}

	returnList->find("Features")->set(moduleFeatures) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void YangManagerTestHelper::getStatus( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// *
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * ENUM(Initialised:Uninitialised:Failed) mgrStatus
	//

	// Insert your code here : %%-->
    std::shared_ptr<YangMgrService> yangService(YangMgrService::singleton()) ;
	std::shared_ptr<YangMgrServer> yangMgr(yangService->getYangMgrServer()) ;

	IYangModuleMgr::Status_E status = yangMgr->getStaus();

	std::string statusStr;
	switch (status)
	{
	case IYangModuleMgr::Status_E::INITIALISED:
		statusStr = "Initialised";
		break;

	case IYangModuleMgr::Status_E::UNINITIALISED:
		statusStr = "Uninitialised";
		break;

	case IYangModuleMgr::Status_E::FAILED:
		statusStr = "Failed";
		break;
	}
	returnList->find("mgrStatus")->set(statusStr);

	// <--%%
}










// Add any statics, private methods etc here %%-->
std::string YangManagerTestHelper::getParamValue(std::shared_ptr<YangParam> param)
{
	std::string ret = "";

	switch(param->getType())
	{
		case YangParamType_E::BOOL:
			ret = (param->getBool() == true ? "true" : "false");
			break;
		case YangParamType_E::INT8:
			ret = std::to_string(param->getInt8());
			break;
		case YangParamType_E::INT16:
			ret = std::to_string(param->getInt16());
			break;
		case YangParamType_E::INT32:
			ret = std::to_string(param->getInt32());
			break;
		case YangParamType_E::INT64:
			ret = std::to_string(param->getInt64());
			break;
		case YangParamType_E::UINT8:
			ret = std::to_string(param->getUInt8());
			break;
		case YangParamType_E::UINT16:
			ret = std::to_string(param->getUInt16());
			break;
		case YangParamType_E::UINT32:
			ret = std::to_string(param->getUInt32());
			break;
		case YangParamType_E::UINT64:
			ret = std::to_string(param->getUInt64());
			break;
		case YangParamType_E::STRING:
			ret = param->getString();
			std::cout << "Found string : " << ret << std::endl;
			break;

		case YangParamType_E::UNKNOWN:
		default:
			break;
	}

	return ret;
}

// <--%%
