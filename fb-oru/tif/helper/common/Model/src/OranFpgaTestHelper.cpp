/*!
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * \file      OranFpgaTestHelper.cpp
 * \brief     Test helper for common
 *
 *
 * \details   Auto-generated by gentool. Contains test interface definitions. Please add your own
 * code between the %%--> and <--%% comment lines (any code outside these comments will be discarded
 * next time the generate tool is run)
 *
 */


//=============================================================================================================
// INCLUDE
//=============================================================================================================
#include "RtiKeyword.h"
#include "OranFpgaTestHelper.h"

// Add any specific includes here %%-->
#include "IFpgaMgr.h"
// <--%%


using namespace Mplane ;

// Add any statics, types, prototypes etc here %%-->

namespace {

	const std::string EXPECTED_HEX("0123456789abcdefABCDEF") ;

	bool hexpair2val(const std::string& str, unsigned index, uint16_t& val, DataVariantList *returnList)
	{
		std::string pair(str.substr(index, 2)) ;
		if (pair.find_first_not_of(EXPECTED_HEX) != std::string::npos)
		{
			returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
			returnList->find(RtiKeyword::MESSAGE_VAR)->set("Invalid MAC id string") ;
			return false ;
		}

		val = (uint16_t)stoi(pair, nullptr, 16) ;
		return true ;
	}


}
// <--%%



//=============================================================================================================
// SINGLETON
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
std::shared_ptr<OranFpgaTestHelper> OranFpgaTestHelper::getInstance()
{
	static std::shared_ptr<OranFpgaTestHelper> instance(std::make_shared<OranFpgaTestHelper>()) ;
	return instance ;
}

//=============================================================================================================
// PUBLIC
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
OranFpgaTestHelper::OranFpgaTestHelper()
// Insert additional inheritance constructors here : %%-->

// <--%%
{
	// Insert your code here : %%-->


	// <--%%
}

//-------------------------------------------------------------------------------------------------------------
OranFpgaTestHelper::~OranFpgaTestHelper()
{
	// Insert your code here : %%-->

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::dstMac( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// * STRING mac
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->
	uint16_t hi, mid, lo ;
	if (!macStr2Val(callList->find("mac")->toString(), hi, mid, lo, returnList))
		return ;

	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	fpga->write_uplaneDestMacHi(fibreIq, hi) ;
	fpga->write_uplaneDestMacMid(fibreIq, mid) ;
	fpga->write_uplaneDestMacLo(fibreIq, lo) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::getDstMac( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING mac
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	uint16_t hi = fpga->read_uplaneDestMacHi(fibreIq) ;
	uint16_t mid = fpga->read_uplaneDestMacMid(fibreIq) ;
	uint16_t lo = fpga->read_uplaneDestMacLo(fibreIq) ;

	returnList->find("mac")->set(macVal2Str(hi, mid, lo)) ;


	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::getRtcId( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * UINT{0..1048575} id
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	uint16_t id = fpga->read_rtcPcId(fibreIq) ;
	returnList->find("id")->setInt(id) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::getSrcMac( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING mac
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	uint16_t hi = fpga->read_cuplaneSrcMacHi(fibreIq) ;
	uint16_t mid = fpga->read_cuplaneSrcMacMid(fibreIq) ;
	uint16_t lo = fpga->read_cuplaneSrcMacLo(fibreIq) ;

	returnList->find("mac")->set(macVal2Str(hi, mid, lo)) ;


	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::getUplaneTag( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * UINT{0..65535} tag
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	unsigned tag(fpga->read_uplaneVlanTag(fibreIq)) ;

	returnList->find("tag")->setUint(tag) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::getVlanEnable( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * BOOL enable
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	unsigned enable(fpga->read_uplaneVlanEnable(fibreIq)) ;
	returnList->find("enable")->setBool(enable > 0) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::rtcId( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// * UINT{0..1048575} id
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	unsigned id(callList->find("id")->toUint()) ;
	fpga->write_rtcPcId(fibreIq, id) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::srcMac( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// * STRING mac
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->
	uint16_t hi, mid, lo ;
	if (!macStr2Val(callList->find("mac")->toString(), hi, mid, lo, returnList))
		return ;

	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	fpga->write_cuplaneSrcMacHi(fibreIq, hi) ;
	fpga->write_cuplaneSrcMacMid(fibreIq, mid) ;
	fpga->write_cuplaneSrcMacLo(fibreIq, lo) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::uplaneTag( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// * UINT{0..65535} tag
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	unsigned tag(callList->find("tag")->toUint()) ;

	fpga->write_uplaneVlanTag(fibreIq, tag) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void OranFpgaTestHelper::vlanEnable( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * UINT{0..65535} index
	// * BOOL enable
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->
	auto fpga(IFpgaMgr::getIFpgaOranRegs()) ;

	unsigned fibreIq(callList->find("index")->toUint()) ;
	bool enable(callList->find("enable")->toBool()) ;
	fpga->write_uplaneVlanEnable(fibreIq, enable ? 1 : 0) ;
	// <--%%
}










// Add any statics, private methods etc here %%-->

//=============================================================================================================
// PRIVATE
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
bool Mplane::OranFpgaTestHelper::macStr2Val(const std::string &macstr,
		uint16_t &hi, uint16_t &mid, uint16_t &lo, DataVariantList *returnList)
{
	// See if string is raw 12-digit hex
	if (macstr.size() == 12)
	{
		if (macstr.find_first_not_of(EXPECTED_HEX) != std::string::npos)
		{
			returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
			returnList->find(RtiKeyword::MESSAGE_VAR)->set("Invalid MAC id string") ;
			return false ;
		}

		// 0   4   8
		// 123456789ABC

		hi  = (uint16_t)stoi(macstr.substr(0, 4), nullptr, 16) ;
		mid = (uint16_t)stoi(macstr.substr(4, 4), nullptr, 16) ;
		lo  = (uint16_t)stoi(macstr.substr(8, 4), nullptr, 16) ;
		return true ;
	}

	// see if character separated hex pairs
	if (macstr.size() == 17)
	{
		char sep(macstr.at(2)) ;
		std::string expected(EXPECTED_HEX + sep) ;
		if (macstr.find_first_not_of(expected) != std::string::npos)
		{
			returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
			returnList->find(RtiKeyword::MESSAGE_VAR)->set("Invalid MAC id string") ;
			return false ;
		}

		uint16_t byte1 ;
		uint16_t byte2 ;

		// 0  3  6  9  12 15
		// 12-34-56-78-9A-BC

		if (!hexpair2val(macstr, 0, byte1, returnList))
			return false ;

		if (!hexpair2val(macstr, 3, byte2, returnList))
			return false ;

		hi = (byte1 << 8) | byte2 ;

		if (!hexpair2val(macstr, 6, byte1, returnList))
			return false ;

		if (!hexpair2val(macstr, 9, byte2, returnList))
			return false ;

		mid = (byte1 << 8) | byte2 ;

		if (!hexpair2val(macstr, 12, byte1, returnList))
			return false ;

		if (!hexpair2val(macstr, 15, byte2, returnList))
			return false ;

		lo = (byte1 << 8) | byte2 ;

		return true ;
	}

	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
	returnList->find(RtiKeyword::MESSAGE_VAR)->set("Invalid MAC id string") ;

	return false ;
}

//-------------------------------------------------------------------------------------------------------------
std::string Mplane::OranFpgaTestHelper::macVal2Str(uint16_t hi, uint16_t mid, uint16_t lo)
{
	const char sep('-') ;

	std::stringstream ss ;
	ss << std::hex ;
	uint16_t byte1, byte2 ;

	byte1 = (hi >> 8) & 0xff ;
	byte2 = hi & 0xff ;
	ss << byte1 << sep << byte2 << sep ;

	byte1 = (mid >> 8) & 0xff ;
	byte2 = mid & 0xff ;
	ss << byte1 << sep << byte2 << sep ;

	byte1 = (lo >> 8) & 0xff ;
	byte2 = lo & 0xff ;
	ss << byte1 << sep << byte2 ;

	return ss.str() ;
}

// <--%%
