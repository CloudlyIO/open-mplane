/*!
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * \file      FreqConstTestHelper.cpp
 * \brief     Test helper for common
 *
 *
 * \details   Auto-generated by gentool. Contains test interface definitions. Please add your own
 * code between the %%--> and <--%% comment lines (any code outside these comments will be discarded
 * next time the generate tool is run)
 *
 */


//=============================================================================================================
// INCLUDE
//=============================================================================================================
#include "RtiKeyword.h"
#include "FreqConstTestHelper.h"

// Add any specific includes here %%-->
#include "IBootEnv.h"

// <--%%


using namespace Mplane ;

// Add any statics, types, prototypes etc here %%-->

// <--%%



//=============================================================================================================
// SINGLETON
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
std::shared_ptr<FreqConstTestHelper> FreqConstTestHelper::getInstance()
{
	static std::shared_ptr<FreqConstTestHelper> instance(std::make_shared<FreqConstTestHelper>()) ;
	return instance ;
}

//=============================================================================================================
// PUBLIC
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
FreqConstTestHelper::FreqConstTestHelper()
// Insert additional inheritance constructors here : %%-->

// <--%%
{
	// Insert your code here : %%-->

	// <--%%
}

//-------------------------------------------------------------------------------------------------------------
FreqConstTestHelper::~FreqConstTestHelper()
{
	// Insert your code here : %%-->

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void FreqConstTestHelper::getRx( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// *
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * FLOAT rx3gMinimum (kHz)
	// * FLOAT rx3gMaximum (kHz)
	// * FLOAT rxFilterMinimum (kHz)
	// * FLOAT rxFilterMaximum (kHz)
	// * FLOAT rxMinimum (kHz)
	// * FLOAT rxMaximum (kHz)
	// * FLOAT rxCentre (kHz)
	// * FLOAT rxBandwidth (kHz)
	// * FLOAT rxRaster (kHz)
	// * ENUM(LOWSIDE:HIGHSIDE) rxCarrierFlip
	// * ENUM(LOWSIDE:HIGHSIDE) rxLoInjection
	//

	// Insert your code here : %%-->

    ReturnType::State returnState;
    std::stringstream string;

    std::shared_ptr<IBootEnv> bootEnv( IBootEnv::getInstance() );
    std::shared_ptr<IFrequencyConst> FrequencyConst( IRxFrequencyConstFactory::getInterface() );

    static std::map<std::string, std::string> ParameterList
    {
        { "rx3gMinimum", "" },
        { "rx3gMaximum", "" },
        { "rxFilterMinimum", "" },
        { "rxFilterMaximum", "" },
        { "rxMinimum", "" },
        { "rxMaximum", "" },
        { "rxCentre", "" },
        { "rxBandwidth", "" },
        { "rxRaster", "" },
        { "rxCarrierFlip", "" },
        { "rxLoInjection", "" }
    };

    if ( FrequencyConst.get() )
    {
        for (auto i = ParameterList.begin(); i != ParameterList.end(); ++i)
        {
            if (bootEnv->isVar( i->first ))
            {
                i->second = bootEnv->getVar(i->first);
            }
            else
            {
                returnState = ReturnType::RT_ERROR;
                string << "Unable to read the frequency constants";
                checkState(returnState, string.str(), returnList);
                return;
            }
        }

        returnState = ReturnType::RT_OK;

        float rx3gMinimum = std::stof(ParameterList["rx3gMinimum"]);
        float rx3gMaximum = std::stof(ParameterList["rx3gMaximum"]);
        float rxFilterMinimum = std::stof(ParameterList["rxFilterMinimum"]);
        float rxFilterMaximum = std::stof(ParameterList["rxFilterMaximum"]);
        float rxMinimum = std::stof(ParameterList["rxMinimum"]);
        float rxMaximum = std::stof(ParameterList["rxMaximum"]);
        float rxCentre = std::stof(ParameterList["rxCentre"]);
        float rxBandwidth = std::stof(ParameterList["rxBandwidth"]);
        float rxRaster = std::stof(ParameterList["rxRaster"]);
        HighLow rxCarrierFlip;
        HighLow rxLoInjection;

        if (ParameterList["rxCarrierFlip"] == "HIGHSIDE")
        {
            rxCarrierFlip = HighLow::HIGHSIDE;
            returnList->find("rxCarrierFlip")->set(rxCarrierFlip);
        }
        else if (ParameterList["rxCarrierFlip"] == "LOWSIDE")
        {
            rxCarrierFlip = HighLow::LOWSIDE;
            returnList->find("rxCarrierFlip")->set(rxCarrierFlip);
        }

        if (ParameterList["rxLoInjection"] == "HIGHSIDE")
        {
            rxLoInjection = HighLow::HIGHSIDE;
            returnList->find("rxLoInjection")->set(rxLoInjection);
        }
        else if (ParameterList["rxLoInjection"] == "LOWSIDE")
        {
            rxLoInjection = HighLow::LOWSIDE;
            returnList->find("rxLoInjection")->set(rxLoInjection);
        }

        returnList->find("rx3gMinimum")->set(rx3gMinimum);
        returnList->find("rx3gMaximum")->set(rx3gMaximum);
        returnList->find("rxFilterMinimum")->set(rxFilterMinimum);
        returnList->find("rxFilterMaximum")->set(rxFilterMaximum);
        returnList->find("rxMinimum")->set(rxMinimum);
        returnList->find("rxMaximum")->set(rxMaximum);
        returnList->find("rxCentre")->set(rxCentre);
        returnList->find("rxBandwidth")->set(rxBandwidth);
        returnList->find("rxRaster")->set(rxRaster);

    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable to obtain the Rx Frequency Constant interface";
    }

    checkState(returnState, string.str(), returnList);
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void FreqConstTestHelper::getTx( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// *
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * FLOAT tx3gMinimum (kHz)
	// * FLOAT tx3gMaximum (kHz)
	// * FLOAT txFilterMinimum (kHz)
	// * FLOAT txFilterMaximum (kHz)
	// * FLOAT txMinimum (kHz)
	// * FLOAT txMaximum (kHz)
	// * FLOAT txCentre (kHz)
	// * FLOAT txBandwidth (kHz)
	// * FLOAT txRaster (kHz)
	// * ENUM(LOWSIDE:HIGHSIDE) txCarrierFlip
	// * ENUM(LOWSIDE:HIGHSIDE) txLoInjection
	//

	// Insert your code here : %%-->

    ReturnType::State returnState;
    std::stringstream string;

    std::shared_ptr<IBootEnv> bootEnv( IBootEnv::getInstance() );
    std::shared_ptr<IFrequencyConst> FrequencyConst( ITxFrequencyConstFactory::getInterface() );

    static std::map<std::string, std::string> ParameterList
    {
        { "tx3gMinimum", "" },
        { "tx3gMaximum", "" },
        { "txFilterMinimum", "" },
        { "txFilterMaximum", "" },
        { "txMinimum", "" },
        { "txMaximum", "" },
        { "txCentre", "" },
        { "txBandwidth", "" },
        { "txRaster", "" },
        { "txCarrierFlip", "" },
        { "txLoInjection", "" }
    };

    if ( FrequencyConst.get() )
    {
        for (auto i = ParameterList.begin(); i != ParameterList.end(); ++i)
        {
            if (bootEnv->isVar( i->first ))
            {
                i->second = bootEnv->getVar(i->first);
            }
            else
            {
                returnState = ReturnType::RT_ERROR;
                string << "Unable to read the frequency constants";
                checkState(returnState, string.str(), returnList);
                return;
            }
        }

        returnState = ReturnType::RT_OK;

        float tx3gMinimum = std::stof(ParameterList["tx3gMinimum"]);
        float tx3gMaximum = std::stof(ParameterList["tx3gMaximum"]);
        float txFilterMinimum = std::stof(ParameterList["txFilterMinimum"]);
        float txFilterMaximum = std::stof(ParameterList["txFilterMaximum"]);
        float txMinimum = std::stof(ParameterList["txMinimum"]);
        float txMaximum = std::stof(ParameterList["txMaximum"]);
        float txCentre = std::stof(ParameterList["txCentre"]);
        float txBandwidth = std::stof(ParameterList["txBandwidth"]);
        float txRaster = std::stof(ParameterList["txRaster"]);
        HighLow txCarrierFlip;
        HighLow txLoInjection;

        if (ParameterList["txCarrierFlip"] == "HIGHSIDE")
        {
            txCarrierFlip = HighLow::HIGHSIDE;
            returnList->find("txCarrierFlip")->set(txCarrierFlip);
        }
        else if (ParameterList["txCarrierFlip"] == "LOWSIDE")
        {
            txCarrierFlip = HighLow::LOWSIDE;
            returnList->find("txCarrierFlip")->set(txCarrierFlip);
        }

        if (ParameterList["txLoInjection"] == "HIGHSIDE")
        {
            txLoInjection = HighLow::HIGHSIDE;
            returnList->find("txLoInjection")->set(txLoInjection);
        }
        else if (ParameterList["txLoInjection"] == "LOWSIDE")
        {
            txLoInjection = HighLow::LOWSIDE;
            returnList->find("txLoInjection")->set(txLoInjection);
        }

        returnList->find("tx3gMinimum")->set(tx3gMinimum);
        returnList->find("tx3gMaximum")->set(tx3gMaximum);
        returnList->find("txFilterMinimum")->set(txFilterMinimum);
        returnList->find("txFilterMaximum")->set(txFilterMaximum);
        returnList->find("txMinimum")->set(txMinimum);
        returnList->find("txMaximum")->set(txMaximum);
        returnList->find("txCentre")->set(txCentre);
        returnList->find("txBandwidth")->set(txBandwidth);
        returnList->find("txRaster")->set(txRaster);

    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable to obtain the Tx Frequency Constant interface";
    }

    checkState(returnState, string.str(), returnList);
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void FreqConstTestHelper::setRx( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * [FLOAT{0..} 3gMinimum (kHz)]
	// * [FLOAT{0..} 3gMaximum (kHz)]
	// * [FLOAT{0..} filterMinimum (kHz)]
	// * [FLOAT{0..} filterMaximum (kHz)]
	// * [FLOAT{0..} minimum (kHz)]
	// * [FLOAT{0..} maximum (kHz)]
	// * [FLOAT{0..} centre (kHz)]
	// * [FLOAT{0..} bandwidth (kHz)]
	// * [FLOAT{0..} raster (kHz)]
	// * [ENUM(LOWSIDE:HIGHSIDE) carrierFlip]
	// * [ENUM(LOWSIDE:HIGHSIDE) loInjection]
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;
    std::stringstream string;

    std::shared_ptr<IBootEnv> bootEnv( IBootEnv::getInstance() );
    std::shared_ptr<IFrequencyConst> FrequencyConst( IRxFrequencyConstFactory::getInterface() );

    if ( FrequencyConst.get() )
    {
        bool result = true;

        // * [FLOAT{0..} 3gMinimum (kHz)]
        DataVariant* _3gMinimum(callList->find("3gMinimum")) ;
        if (_3gMinimum->isSet())
        {
            std::string _3gMinimumStr(_3gMinimum->toString());
            result &= bootEnv->setVar("rx3gMinimum", _3gMinimumStr);
        }

        // * [FLOAT{0..} 3gMaximum (kHz)]
        DataVariant* _3gMaximum(callList->find("3gMaximum")) ;
        if (_3gMaximum->isSet())
        {
            std::string _3gMaximumStr(_3gMaximum->toString());
            result &= bootEnv->setVar("rx3gMaximum", _3gMaximumStr);
        }

        // * [FLOAT{0..} filterMinimum (kHz)]
        DataVariant* filterMinimum(callList->find("filterMinimum")) ;
        if (filterMinimum->isSet())
        {
            std::string filterMinimumStr(filterMinimum->toString());
            result &= bootEnv->setVar("rxFilterMinimum", filterMinimumStr);
        }

        // * [FLOAT{0..} filterMaximum (kHz)]
        DataVariant* filterMaximum(callList->find("filterMaximum")) ;
        if (filterMaximum->isSet())
        {
            std::string filterMaximumStr(filterMaximum->toString());
            result &= bootEnv->setVar("rxFilterMaximum", filterMaximumStr);
        }

        // * [FLOAT{0..} minimum (kHz)]
        DataVariant* minimum(callList->find("minimum")) ;
        if (minimum->isSet())
        {
            std::string minimumStr(minimum->toString());
            result &= bootEnv->setVar("rxMinimum", minimumStr);
        }

        // * [FLOAT{0..} maximum (kHz)]
        DataVariant* maximum(callList->find("maximum")) ;
        if (maximum->isSet())
        {
            std::string maximumStr(maximum->toString());
            result &= bootEnv->setVar("rxMaximum", maximumStr);
        }

        // * [FLOAT{0..} centre (kHz)]
        DataVariant* centre(callList->find("centre")) ;
        if (centre->isSet())
        {
            std::string centreStr(centre->toString());
            result &= bootEnv->setVar("rxCentre", centreStr);
        }

        // * [FLOAT{0..} bandwidth (kHz)]
        DataVariant* bandwidth(callList->find("bandwidth")) ;
        if (bandwidth->isSet())
        {
            std::string bandwidthStr(bandwidth->toString());
            result &= bootEnv->setVar("rxBandwidth", bandwidthStr);
        }

        // * [FLOAT{0..} raster (kHz)]
        DataVariant* raster(callList->find("raster")) ;
        if (raster->isSet())
        {
            std::string rasterStr(raster->toString());
            result &= bootEnv->setVar("rxRaster", rasterStr);
        }

        // * [ENUM(LOWSIDE:HIGHSIDE) carrierFlip]
        DataVariant* carrierFlip(callList->find("carrierFlip")) ;
        if (carrierFlip->isSet())
        {
            std::string carrierFlipStr(carrierFlip->toString());
            result &= bootEnv->setVar("rxCarrierFlip", carrierFlipStr);
        }

        // * [ENUM(LOWSIDE:HIGHSIDE) loInjection]
        DataVariant* loInjection(callList->find("loInjection")) ;
        if (loInjection->isSet())
        {
            std::string loInjectionStr(loInjection->toString());
            result &= bootEnv->setVar("rxLoInjection", loInjectionStr);
        }


        if ( !result )
        {
            returnState = ReturnType::RT_ERROR;
            string << "Unable to write one or more parameters";
        }
    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable to obtain the Rx Frequency Constant interface";
    }

    checkState(returnState, string.str(), returnList);
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void FreqConstTestHelper::setTx( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * [FLOAT{0..} 3gMinimum (kHz)]
	// * [FLOAT{0..} 3gMaximum (kHz)]
	// * [FLOAT{0..} filterMinimum (kHz)]
	// * [FLOAT{0..} filterMaximum (kHz)]
	// * [FLOAT{0..} minimum (kHz)]
	// * [FLOAT{0..} maximum (kHz)]
	// * [FLOAT{0..} centre (kHz)]
	// * [FLOAT{0..} bandwidth (kHz)]
	// * [FLOAT{0..} raster (kHz)]
	// * [ENUM(LOWSIDE:HIGHSIDE) carrierFlip]
	// * [ENUM(LOWSIDE:HIGHSIDE) loInjection]
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;
    std::stringstream string;

    std::shared_ptr<IBootEnv> bootEnv( IBootEnv::getInstance() );
    std::shared_ptr<IFrequencyConst> FrequencyConst( ITxFrequencyConstFactory::getInterface() );

    if ( FrequencyConst.get() )
    {
        bool result = true;

        // * [FLOAT{0..} 3gMinimum (kHz)]
        DataVariant* _3gMinimum(callList->find("3gMinimum")) ;
        if (_3gMinimum->isSet())
        {
            std::string _3gMinimumStr(_3gMinimum->toString());
            result &= bootEnv->setVar("tx3gMinimum", _3gMinimumStr);
        }

        // * [FLOAT{0..} 3gMaximum (kHz)]
        DataVariant* _3gMaximum(callList->find("3gMaximum")) ;
        if (_3gMaximum->isSet())
        {
            std::string _3gMaximumStr(_3gMaximum->toString());
            result &= bootEnv->setVar("tx3gMaximum", _3gMaximumStr);
        }

        // * [FLOAT{0..} filterMinimum (kHz)]
        DataVariant* filterMinimum(callList->find("filterMinimum")) ;
        if (filterMinimum->isSet())
        {
            std::string filterMinimumStr(filterMinimum->toString());
            result &= bootEnv->setVar("txFilterMinimum", filterMinimumStr);
        }

        // * [FLOAT{0..} filterMaximum (kHz)]
        DataVariant* filterMaximum(callList->find("filterMaximum")) ;
        if (filterMaximum->isSet())
        {
            std::string filterMaximumStr(filterMaximum->toString());
            result &= bootEnv->setVar("txFilterMaximum", filterMaximumStr);
        }

        // * [FLOAT{0..} minimum (kHz)]
        DataVariant* minimum(callList->find("minimum")) ;
        if (minimum->isSet())
        {
            std::string minimumStr(minimum->toString());
            result &= bootEnv->setVar("txMinimum", minimumStr);
        }

        // * [FLOAT{0..} maximum (kHz)]
        DataVariant* maximum(callList->find("maximum")) ;
        if (maximum->isSet())
        {
            std::string maximumStr(maximum->toString());
            result &= bootEnv->setVar("txMaximum", maximumStr);
        }

        // * [FLOAT{0..} centre (kHz)]
        DataVariant* centre(callList->find("centre")) ;
        if (centre->isSet())
        {
            std::string centreStr(centre->toString());
            result &= bootEnv->setVar("txCentre", centreStr);
        }

        // * [FLOAT{0..} bandwidth (kHz)]
        DataVariant* bandwidth(callList->find("bandwidth")) ;
        if (bandwidth->isSet())
        {
            std::string bandwidthStr(bandwidth->toString());
            result &= bootEnv->setVar("txBandwidth", bandwidthStr);
        }

        // * [FLOAT{0..} raster (kHz)]
        DataVariant* raster(callList->find("raster")) ;
        if (raster->isSet())
        {
            std::string rasterStr(raster->toString());
            result &= bootEnv->setVar("txRaster", rasterStr);
        }

        // * [ENUM(LOWSIDE:HIGHSIDE) carrierFlip]
        DataVariant* carrierFlip(callList->find("carrierFlip")) ;
        if (carrierFlip->isSet())
        {
            std::string carrierFlipStr(carrierFlip->toString());
            result &= bootEnv->setVar("txCarrierFlip", carrierFlipStr);
        }

        // * [ENUM(LOWSIDE:HIGHSIDE) loInjection]
        DataVariant* loInjection(callList->find("loInjection")) ;
        if (loInjection->isSet())
        {
            std::string loInjectionStr(loInjection->toString());
            result &= bootEnv->setVar("txLoInjection", loInjectionStr);
        }


        if ( !result )
        {
            returnState = ReturnType::RT_ERROR;
            string << "Unable to write one or more parameters";
        }
    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable to obtain the Tx Frequency Constant interface";
    }

    checkState(returnState, string.str(), returnList);
	// <--%%
}










// Add any statics, private methods etc here %%-->

bool FreqConstTestHelper::checkState(ReturnType::State ret, const std::string& param, DataVariantList *returnList) const
{
    if (ret != ReturnType::RT_OK)
    {
        // set an error
        returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );

        std::stringstream ss ;
        ss << param << " : ERROR" << ReturnType::getState(ret) ;
        returnList->find(RtiKeyword::MESSAGE_VAR)->set(ss.str()) ;

        return false ;
    }

    return true ;
}

// <--%%
