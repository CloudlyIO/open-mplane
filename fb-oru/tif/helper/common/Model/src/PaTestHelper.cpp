/*!
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * \file      PaTestHelper.cpp
 * \brief     Test helper for common
 *
 *
 * \details   Auto-generated by gentool. Contains test interface definitions. Please add your own
 * code between the %%--> and <--%% comment lines (any code outside these comments will be discarded
 * next time the generate tool is run)
 *
 */


//=============================================================================================================
// INCLUDE
//=============================================================================================================
#include "RtiKeyword.h"
#include "PaTestHelper.h"

// Add any specific includes here %%-->

// <--%%


using namespace Mplane ;

// Add any statics, types, prototypes etc here %%-->
#include "IPa.h"

// <--%%



//=============================================================================================================
// SINGLETON
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
std::shared_ptr<PaTestHelper> PaTestHelper::getInstance()
{
	static std::shared_ptr<PaTestHelper> instance(std::make_shared<PaTestHelper>()) ;
	return instance ;
}

//=============================================================================================================
// PUBLIC
//=============================================================================================================

//-------------------------------------------------------------------------------------------------------------
PaTestHelper::PaTestHelper()
// Insert additional inheritance constructors here : %%-->

// <--%%
{
	// Insert your code here : %%-->


	// <--%%
}

//-------------------------------------------------------------------------------------------------------------
PaTestHelper::~PaTestHelper()
{
	// Insert your code here : %%-->

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::disable( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING result
	//

	// Insert your code here : %%-->
    ReturnType::State returnState;
    std::stringstream string;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
        returnState = paPort->setPaDisable();

        if( ReturnType::RT_OK == returnState )
        {
            string << "PA disabled";
        }
        else
        {
            string << "Command was not successful";
        }
    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable obtain the PA interface";
    }

    checkState(returnState, string.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(string.str()) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::enable( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING result
	//

	// Insert your code here : %%-->
    ReturnType::State returnState;
    std::stringstream string;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
        returnState = paPort->setPaEnable();

        if( ReturnType::RT_OK == returnState )
        {
            string << "PA enabled";
        }
        else
        {
            string << "Command was not successful";
        }
    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable obtain the PA interface";
    }

    checkState(returnState, string.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(string.str()) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::getID( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * [INT index=1]
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING[] result
	//

	// Insert your code here : %%-->
	std::stringstream string;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
		bool isPaConnected = paPort->isConnected();

		if( true == isPaConnected )
		{
			UINT16 paID = paPort->getID();

			string << "PA Id [1:0] = [" ;
			string << std::dec << (unsigned)((paID & 0xff00) >> 2) ;
			string << ":" ;
			string << std::dec << (unsigned)(paID & 0x00ff) ;
			string << "]";
		}
		else
		{
			string << "PA is not connected!" ;
		}
    }

    returnList->find(RtiKeyword::INFO_VAR)->set(string.str()) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::getPaGainManual( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING state
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;

	std::stringstream ss;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if ( paPort.get() )
    {
        UINT16 readCtrlRawValue = 0xff;

        if (paPort->getPaGainManualCtrl(readCtrlRawValue))
        {
            DataVariant* state(returnList->find("state")) ;

            if (readCtrlRawValue != 0)
            {
            	ss << " HIGH GAIN " ;
            }
            else
            {
            	ss << " LOW GAIN " ;
            }
            state->set( ss.str() );
        }
        else
        {
        	// if not supported by the implementation then let the user know
        	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
        	std::stringstream ss ;
        	ss << " This command is not supported " ;
        	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
        	return;
        }
    }

    checkState(returnState, ss.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(ss.str()) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::getPaGainOverride( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING state
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;

	std::stringstream ss;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if ( paPort.get() )
    {
        UINT16 readOverrideRawValue = 0xff;

        if (paPort->getPaGainOverride(readOverrideRawValue))
        {
            DataVariant* state(returnList->find("state")) ;

            if (readOverrideRawValue != 0)
            {
            	ss << " ON " ;
            }
            else
            {
            	ss << " OFF " ;
            }
            state->set( ss.str() );
        }
        else
        {
        	// if not supported by the implementation then let the user know
        	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
        	std::stringstream ss ;
        	ss << " This command is not supported " ;
        	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
        	return;
        }
    }

    checkState(returnState, ss.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(ss.str()) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::getState( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING result
	//

	// Insert your code here : %%-->
    ReturnType::State returnState;
    std::stringstream string;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
        IPa::paState_T mPaState;
        returnState = paPort->getPaState(mPaState);

        if( ReturnType::RT_OK == returnState )
        {
            if( IPa::PA_ENABLED == mPaState )
            {
                string << "PA is enabled";
            }
            else
            {
                string << "PA is disabled";
            }
        }
        else
        {
            string << "Unable to determine the PA state";
        }
    }
    else
    {
        returnState = ReturnType::RT_ERROR;
        string << "Unable to obtain the PA interface";
    }

    checkState(returnState, string.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(string.str()) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::getTemperature( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// * [INT sensor=1]
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * FLOAT result (DegC)
	//

	// Insert your code here : %%-->
    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
		int sensor = callList->find("sensor")->toInt();

		if( sensor <= paPort->numberTempSensorsPerPa() )
		{
			float temp = paPort->getTemperature((IPa::paTempSensor_T)sensor);

			returnList->find("result")->set( temp );
		}
		else
		{
		    ReturnType::State ret = ReturnType::RT_OUT_OF_RANGE;
		    std::stringstream messageString;

		    messageString << "Temperature Sensor is out of range. Max number of sensors is - " << (unsigned)paPort->numberTempSensorsPerPa();

		    checkState(ret, messageString.str(), returnList);
		}
    }
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::isConnected( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	// * STRING[] result
	//

	// Insert your code here : %%-->
	std::stringstream string;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if( paPort.get() )
    {
		bool isPaConnected = paPort->isConnected();

		if( true == isPaConnected )
		{
			string << "PA is connected";
		}
		else
		{
			string << "PA is not connected";
		}
    }

    returnList->find(RtiKeyword::INFO_VAR)->set(string.str()) ;
	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::setPaGainManual( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// * ENUM(low:high) mode
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;

	std::stringstream ss;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if ( paPort.get() )
    {
        // get the mode
        if (callList->find("mode")->toString() == "low")
        {
        	if (!paPort->setPaGainManualCtrl(0))
        	{
            	// if not supported by the implementation then let the user know
            	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
            	std::stringstream ss ;
            	ss << " This command is not supported " ;
            	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
            	return;
        	}
        }
        else if (callList->find("mode")->toString() == "high")
        {
        	if (!paPort->setPaGainManualCtrl(1))
        	{
            	// if not supported by the implementation then let the user know
            	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
            	std::stringstream ss ;
            	ss << " This command is not supported " ;
            	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
            	return;
        	}
        }
        else
        {
        	returnState = ReturnType::RT_NOT_SUPPORTED;
        }
    }

    checkState(returnState, ss.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(ss.str()) ;

	// <--%%
}


//-------------------------------------------------------------------------------------------------------------
void PaTestHelper::setPaGainOverride( IRtiMsgParser& msgParser, DataVariantList *callList, DataVariantList *returnList )
{
	// Called with:
	// * INT index=1
	// * ENUM(on:off) mode
	// Returns:
	// * ENUM(OK:ERROR) Status=OK
	// * [STRING Info]
	// * [STRING Message]
	//

	// Insert your code here : %%-->

    ReturnType::State returnState = ReturnType::RT_OK;

	std::stringstream ss;

    std::shared_ptr<IPa> paPort = getPaInterface( callList, returnList );

    if ( paPort.get() )
    {
        // get the mode
        if (callList->find("mode")->toString() == "on")
        {
        	if (!paPort->setPaGainOverride(1))
        	{
            	// if not supported by the implementation then let the user know
            	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
            	std::stringstream ss ;
            	ss << " This command is not supported " ;
            	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
            	return;
        	}
        }
        else if (callList->find("mode")->toString() == "off")
        {
        	if (!paPort->setPaGainOverride(0))
        	{
            	// if not supported by the implementation then let the user know
            	returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );
            	std::stringstream ss ;
            	ss << " This command is not supported " ;
            	returnList->find(RtiKeyword::MESSAGE_VAR)->set( ss.str() );
            	return;
        	}
        }
        else
        {
        	returnState = ReturnType::RT_NOT_SUPPORTED;
        }
    }

    checkState(returnState, ss.str(), returnList);
    returnList->find(RtiKeyword::INFO_VAR)->set(ss.str()) ;

	// <--%%
}










// Add any statics, private methods etc here %%-->
std::shared_ptr<IPa> PaTestHelper::getPaInterface(DataVariantList *callList, DataVariantList *returnList) const
{
    std::vector<std::shared_ptr<IPa> > paPorts = IPaFactory::getPAs();

    int index = getIndex(callList, returnList);

    if( index < 0 || index >= IPaFactory::getNumberOfPAs() )
    {
        returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );

        std::stringstream ss ;
        ss << "index " << index+1 << " outside valid range (Number of ports "
                <<IPaFactory::getNumberOfPAs() << ")" ;
        returnList->find(RtiKeyword::MESSAGE_VAR)->set(ss.str()) ;

        return std::shared_ptr<IPa>() ;
    }

	return paPorts[index];
}

int PaTestHelper::getIndex(DataVariantList* callList,
        DataVariantList* returnList) const
{
    int index = callList->find("index")->toInt();
    return index-1;    // convert port number to internal software index
}

bool PaTestHelper::checkState(ReturnType::State ret, const std::string& param, DataVariantList *returnList) const
{
    if (ret != ReturnType::RT_OK)
    {
        // set an error
        returnList->find(RtiKeyword::STATUS_VAR)->set( RtiKeyword::StatusERROR );

        std::stringstream ss ;
        ss << param << " : ERROR" << ReturnType::getState(ret) ;
        returnList->find(RtiKeyword::MESSAGE_VAR)->set(ss.str()) ;

        return false ;
    }

    return true ;
}

// <--%%
