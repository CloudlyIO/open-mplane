/**
\mainpage Test Interface Helpers
<BR>
<CENTER>
\
Copyright (c) Meta Platforms, Inc. and affiliates.
</CENTER>

<hr>
\section tif_helpers_scope Scope
<hr>

This document is intended to provide an overview of the Test Interface test helpers and
the source code generator used to maintain a common interface between internal
and external developers and testers.

<hr>
\section tif_helpers_overview	Overview
<hr>

This design overview describes the directory structure and organisation of the TIF files and how they are
used to create and maintain the test interface.

<hr>
\section tif_helpers_dir	Directory Structure
<hr>

@image html tif-helper-dir.png "Directory Structure"

The diagram above shows the basic tif directory structure. The <b>common</b> directory contains common library parts (such as the TIF command line processing, and the base test interface class) without
any specific test commands.

All of the test commands are contained under <b>common-model</b> and the board-specific directories shown. These directories contain <i>test handlers</i> which build the TIF device tree and commands displayed
in the test interface. As will be seen shortly, all of this code is auto-generated by the <A HREF="../tif-bin-utils-gentool/index.html" target="_blank"><b>GenTool</b></a> generator tool.

Alongside these directories is the <b>helper</b> directory. This contains the usual subdirectories <b>common</b>, and board-specific subdirectories. These subdirectories hold the <i>test helper</i> code. Again this
code is initially created and then maintained by the <A HREF="../tif-bin-utils-gentool/index.html" target="_blank"><b>GenTool</b></a> generator tool, but must also contain user code to actually perform the operations.

The fundamental idea behind this directory structure is that all the code doing the work of the commands is now performed by the test helpers stored under the <b>helper</b> directory. Applications can then
create xml files which link to whichever commands they require, and the generator tool will automatically create the code to use these helper commands. So, assuming helper already exist, adding new application
commands is simply a case of creating the appropriate xml file and then running the generator.

<hr>
\section tif_helpers_usage	Using the framework
<hr>

This section describes how the test commands are now created, code generated, and user code added to build the TIF interface for an application.

As mentioned above, test helpers do all the work and test handlers merely "link" into the helpers, allowing different applications to choose which of the helper commands they use.

The approach for creating a comletely new set of commands is:

\li Create a new helper xml file
\li Run the GenTool to create a skeleton test helper
\li Add user code to the test helper
\li Create a new application-specific test handler xml file (using xinclude to link to the helper xml commands)
\li Run the GenTool to create the complete test handler

As an example of the process I'll walk you through creation of the Bist commands (note that the Bist xml consists only of variables, but the sequence is exactly the same for any xml file)

\subsection tif_helpers_usage_1 Create a new helper xml file

In the directory <b>tif/helper/common/xml</b> we'll create a new xml file Bist.xml:
\code
<?xml version="1.0"?>
<!DOCTYPE TestInterface SYSTEM "../../../shared/dtd/Tif.dtd">
<TestInterface version="1.0">
 	<Board name="common">
 		<Device name="Bist" path="/bist" comment="Built-in Self Test">
			<Variable name="Initialisation" type="BOOL(FAIL:PASS)" access="read-only" comment="Software initialised all devices correctly" />
			<Variable name="PLL" type="BOOL(FAIL:PASS)" access="read-only" comment="All PLLs are locked" />
 		</Device>
	</Board>
</TestInterface>
\endcode

This example just has two variables, but the xml could well contain multiple functions as well.

\subsection tif_helpers_usage_2 Run the GenTool to create a skeleton test helper

Now we need to run the GenTool to create a helper skeleton. Running the build target <b>test-helpers</b> will
create new files

@image html tif-helper-genhelper.png "Generating the helper skeleton code"

Note that the base device name (Bist) is suffixed with 'TestHelper' to create the class name and the file names.

\subsection tif_helpers_usage_3 Add user code to the test helper

Edit the code to add the functionality between the markers:

@code

...

//-------------------------------------------------------------------------------------------------------------
void BistTestHelper::InitialisationGet( const std::string& pathname, DataVariantList *returnList )
{
	// Getter for "/bist/Initialisation"
	//
	// Return the variable value using the returnList using something like:
	//
	//   returnList->find(pathname)->set(someValue) ;
	//

	// Insert you're code here : %%-->
	// If we've managed to get here then the initialisation must have worked
	returnList->find(pathname)->set(true) ;
	// <--%%
}

//-------------------------------------------------------------------------------------------------------------
void BistTestHelper::PLLGet( const std::string& pathname, DataVariantList *returnList )
{
	// Getter for "/bist/PLL"
	//
	// Return the variable value using the returnList using something like:
	//
	//   returnList->find(pathname)->set(someValue) ;
	//

	// Insert you're code here : %%-->
	returnList->find(pathname)->set(getPllTestResult()) ;
	// <--%%
}

// Add any statics, private methods etc here %%-->
//-------------------------------------------------------------------------------------------------------------
bool BistTestHelper::getPllTestResult()
{
	std::shared_ptr<IAlarmsList> alarmsList(IAlarmsList::getInstance()) ;
	std::shared_ptr<IAlarm> clockAlarm(alarmsList->getAlarm("ClockAlarm")) ;
	if (!clockAlarm)
		return false ;

	return (clockAlarm->isAlarmActive() == false) ;
}
// <--%%


@endcode

\subsection tif_helpers_usage_4 Create a new application-specific test handler xml file (using xinclude to link to the helper xml commands)

We'll add the new bist commands to the ECB-RB-EUROPA application. So create a new xml file under <b>tif/ECB-RB-EUROPA/Model/xml</b>.
The filename doesn't really matter, but to make debugging easier I choose to prefix the device name with the specific directory
I'm creating it as Ecb-Rb-Europa-Bist.xml:

@code
<?xml version="1.0"?>
<!DOCTYPE TestInterface SYSTEM "../../../shared/dtd/Tif.dtd">
<TestInterface version="1.0">
 	<Board name="ECB-RB-EUROPA">
 		<Device name="Bist" path="/bist" comment="Built-in Self Test">
			<xinclude:include href="../../../helper/common/xml/Bist.xml#Initialisation"/>
			<xinclude:include href="../../../helper/common/xml/Bist.xml#PLL"/>
 		</Device>
	</Board>
</TestInterface>

@endcode

As you can see, all this xml file does is link back to the helper xml, linking in whichever commands/variables
we want to use in this application.

@image html tif-helper-xml.png "Example of helper/handler xml include"

As an alternative to having to link to each function/variable used, if the device uses all of the helper defined
device functions/variables, then you can just include that whole device definition. You need to do this
inside your own device definition (which sets the actual device name and path):

@code
<?xml version="1.0"?>
<!DOCTYPE TestInterface SYSTEM "../../../shared/dtd/Tif.dtd">
<TestInterface version="1.0">
 	<Board name="ECB-RB-EUROPA">
 		<Device name="Bist" path="/bist" comment="Built-in Self Test">
			<!-- Include the whole of the Bist device definition -->
			<xinclude:include href="../../../helper/common/xml/Bist.xml#Bist"/>
 		</Device>
	</Board>
</TestInterface>

@endcode



\subsection tif_helpers_usage_5 Run the GenTool to create the complete test handler

Now run GenTool again, but this time to generate the test handler. In this case the handler code will be complete
and will automatically forward all commands to the Bist test helper

@image html tif-helper-genhandler.png "Generating the handler code"

Notice that the GenTool automatically suffixes the name with 'TestHandler' to create the handler class name, and also
prefixes the name with a class-friendly version of the board name specified in the xml file. It does this to ensure
every test handler file created is unique.

Apart from updating the appropriate CMakeLists.txt files to add the new files, that's all that needs to be done.

For any other application wanting to use the new Bist commands, you just need to create the application xml (using xinclude),
then generate the test handler.



*/
